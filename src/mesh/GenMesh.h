#ifndef GENMESH_H
#define GENMESH_H

#include "form/BC.h"
#include "mesh/GlobalSimplexMesh.h"
#include "mesh/MeshData.h"

#include <mpi.h>

#include <array>
#include <cassert>
#include <cmath>
#include <cstddef>
#include <cstdint>
#include <functional>
#include <memory>
#include <utility>
#include <vector>

namespace tndm {

template <std::size_t D> struct TessInfo;
template <> struct TessInfo<1> {
    static constexpr int NumSimplices = 1;
    static constexpr int NumInVertGIDs = 2;
};
template <> struct TessInfo<2> {
    static constexpr int NumSimplices = 2;
    static constexpr int NumInVertGIDs = 4;
};
template <> struct TessInfo<3> {
    static constexpr int NumSimplices = 5;
    static constexpr int NumInVertGIDs = 8;
};

/**
 * @brief Mesh generation class for cuboid meshes
 *
 * @tparam D simplex/space dimension
 */
template <std::size_t D> class GenMesh {
public:
    using mesh_t = GlobalSimplexMesh<D>;
    using simplex_t = typename mesh_t::simplex_t;
    using boundary_mesh_t = GlobalSimplexMesh<D - 1>;
    using boundary_simplex_t = typename boundary_mesh_t::simplex_t;
    using tag_data_t = ScalarMeshData<int>;
    using vertex_data_t = VertexData<D>;
    using vertex_t = typename vertex_data_t::vertex_t;
    using bc_fun_t = std::function<BC(std::size_t, std::array<std::size_t, D - 1u> const&)>;

    /**
     * @brief Tessellate a line (D=1) / rectangle (D=2) / cuboid (D=3) into D-simplices.
     *
     * @param corners global vertex ids
     * @param isOdd
     *
     * @return tessellation
     */
    static std::array<simplex_t, TessInfo<D>::NumSimplices>
    tessellate(std::array<uint64_t, TessInfo<D>::NumInVertGIDs> const& vertGIDs, bool isOdd);

    /**
     * @brief Generate cuboidal mesh.
     *
     * The unit interval [0,1] is partitioned into N[d] equally sized intervals, where d =
     * dimension. A cuboidal mesh is generated by taking the outer product of the partitioned unit
     * intervals. The mesh is then tessellated into triangles or tets.
     *
     * @param N number of elements per dimension
     * @param BCs boundary conditions per dimension (pair.first is BC at x_d == 0 and pair.second is
     * BC at x_d == 1)
     * @param comm MPI communicator
     */
    GenMesh(std::array<uint64_t, D> const& N, std::array<std::pair<BC, BC>, D> const& BCs,
            MPI_Comm comm = MPI_COMM_WORLD)
        : N(N), comm_(comm) {
        for (std::size_t d = 0; d < D; ++d) {
            points_[d] = std::vector{0.0, 1.0};
            regions_[d] = std::vector{0ul, N[d]};
            auto bc = BCs[d];
            bcs_[d] = [bc](std::size_t plane, std::array<std::size_t, D - 1u> const&) {
                if (plane == 0) {
                    return bc.first;
                }
                return bc.second;
            };
        }
        init();
    }

    /**
     * @brief Generate cuboidal mesh with corner points.
     *
     * The outer product of the points vectors ("corner points") gives the vertices of a cuboidal
     * mesh. These points are connected to cubes and then tessellated into triangles or tets.
     *
     * The boundary conditions are passed as functionals of the form
     * [](std::size_t plane, std::array<std::size_t, D - 1u> const& regions) -> BC
     * The plane parameter ranges from 0 to points[d].size() - 1. It indicates the boundary
     * condition that shall be applied to the plane which passes through the point[d][plane]
     * and has its normal in d-direction.
     * The regions parameter are defined such that for dimension d != i we have
     * xb[i] \in [points[i][regions[i]], points[i][regions[i]+1]], where xb[i] is the i-th
     * coordinate of a boundary faces vertex.
     *
     * E.g. let
     * points = {{0.0, 1.0}, {0.0, 0.5, 1.0}} and BCs = {
     *      [](...){ return Diri; },
     *      [](plane, ...) {if (plane == 1) return Fault; return Natural; }
     * }
     * Then the initial mesh looks as following:
     *
     *       Natural
     *  1.0 x-------x
     *      |       |
     *  Diri|       |Diri
     *      | Fault |
     *  0.5 x-------x
     *      |       |
     *  Diri|       |Diri
     *      |Natural|
     *  0.0 x-------x
     *    0.0     1.0
     *
     * The mesh may be refined. The resolution parameter array h guarantees that
     *
     * x[i+1][d] - x[i][d] <= h[d]
     *
     * where x[i] and x[i+1] are adjacent grid points.
     *
     * @param points mesh corner points per dimension (provide at least 2 points per dimension)
     * @param h resolution, guarantees that Delta x <= h
     * @param BCs boundary condition at mesh corner point
     * @param comm MPI communicator
     */
    GenMesh(std::array<std::vector<double>, D> const& points, std::array<double, D> const& h,
            std::array<bc_fun_t, D> BCs, MPI_Comm comm = MPI_COMM_WORLD)
        : points_(points), bcs_(BCs), comm_(comm) {
        auto const initDim = [](double h, std::vector<double> const& points, uint64_t& N,
                                std::vector<uint64_t>& regions) {
            assert(h > 0.0);
            assert(points.size() >= 2);
            N = 0;
            regions.resize(points.size());
            regions[0] = 0;
            for (std::size_t p = 0; p < points.size() - 1u; ++p) {
                assert(points[p + 1] > points[p]);
                N += std::lround((points[p + 1] - points[p]) / h);
                regions[p + 1] = N;
            }
        };
        for (std::size_t d = 0; d < D; ++d) {
            initDim(h[d], points_[d], N[d], regions_[d]);
        }
        init();
    }

    /**
     * @brief Uniform SimplexMesh generation in D dimensions.
     *
     * @param transform Function that maps from the unit square or cube to another domain.
     *
     * @return Mesh of D-simplices and boundary mesh of (D-1)-simplices
     */
    std::unique_ptr<mesh_t> uniformMesh() const;

    std::unique_ptr<boundary_mesh_t> extractBoundaryMesh(mesh_t const& mesh) const;

private:
    void init() {
        // vertices live on grid with size (N_1+1) x ... x (N_d+1)
        for (std::size_t d = 0; d < D; ++d) {
            Np1[d] = N[d] + 1;
        }
    }

    std::size_t findRegion(std::size_t d, std::array<uint64_t, D> const& v) const {
        std::size_t region = 0;
        while (v[d] > regions_[d][region + 1] && region < regions_[d].size() - 1u) {
            ++region;
        }
        assert(region != regions_[d].size() - 1u);
        return region;
    }

    std::array<uint64_t, D> N;
    std::array<std::vector<double>, D> points_;
    std::array<bc_fun_t, D> bcs_;
    MPI_Comm comm_;
    std::array<uint64_t, D> Np1;
    std::array<std::vector<uint64_t>, D> regions_;
};

} // namespace tndm

#endif // GENMESH_H
